(function () {
  'use strict';

  const nativeToSyntheticEvent = (event, name) => {
      const eventKey = `__${name}`;
      let dom = event.target;
      while(dom !== null) {
          const eventHandler = dom[eventKey];
          if (eventHandler) {
              eventHandler();
              return
          }
          dom = dom.parentNode;
      }
  };
  const CONFIGURED_SYNTHETIC_EVENTS = {};
  function setupSyntheticEvent(name) {
      if (CONFIGURED_SYNTHETIC_EVENTS[name]) return
      document.addEventListener(name, event => nativeToSyntheticEvent(event, name));
      CONFIGURED_SYNTHETIC_EVENTS[name] = true;
  }

  function collector(node) {
    if (node.nodeType !== 3) {
      if (node.attributes !== undefined) {
        for(let attr of node.attributes) {
          let aname = attr.name;
          if (aname[0] === '#') {
            node.removeAttribute(aname);
            return aname.slice(1)
          }
        }
      }
      return 0
    } else {
      let nodeData = node.nodeValue;
      if (nodeData[0] === '#') {
        node.nodeValue = "";
        return nodeData.slice(1)
      }
      return 0
    }
  }

  function walker(node) {
    let skip = false, tmp, pathId = '', prevPathId, pahtIdLen, code1, code2, ref;
    code1 = code2 = '';
    if (ref = collector(node)) code2 += `refs.${ref} = node;\n`; 
    do {
        if (!skip && (tmp = node.firstChild)) {
            skip = false;       

            prevPathId = pathId;
            pathId += '_f';
            code1 += `let ${pathId} = ${prevPathId || 'node'}.firstChild;\n`; 

            if (ref = collector(tmp)) code2 += `refs.${ref} = ${pathId};\n`; 
        } else if (tmp = node.nextSibling) {
            skip = false;

            prevPathId = pathId;
            pathId += '_n';
            code1 += `let ${pathId} = ${prevPathId || 'node'}.nextSibling;\n`; 

            if (ref = collector(tmp)) code2 += `refs.${ref} = ${pathId};\n`; 
        } else {
            pahtIdLen = pathId.length;
            if (pathId[pahtIdLen - 1] === 'n') {
                pathId = pathId.slice(0, pathId.lastIndexOf('_f_n'));
            } else {
               pathId = pathId.slice(0, pahtIdLen- 2); 
            }
            tmp = node.parentNode;
            skip = true;
        }
        node = tmp;
    } while (node)
    return Function('node', code1 + 'let refs = {};\n' + code2 + 'return refs;\n')
  }

  const compilerTemplate = document.createElement('template');
  function h(strings) {
    const template = strings[0].replace(/\n*/g, '').replace(/\s*</g, '<').replace(/>\s*/g, '>');
    compilerTemplate.innerHTML = template;
    const content = compilerTemplate.content.firstChild;
    content.collect = walker(content);
    return content
  }

  // This is almost straightforward implementation of reconcillation algorithm
  // based on ivi documentation:
  // https://github.com/localvoid/ivi/blob/2c81ead934b9128e092cc2a5ef2d3cabc73cb5dd/packages/ivi/src/vdom/implementation.ts#L1366
  // With some fast paths from Surplus implementation:
  // https://github.com/adamhaile/surplus/blob/master/src/runtime/content.ts#L86
  //
  // How this implementation differs from others, is that it's working with data directly,
  // without maintaining nodes arrays, and uses dom props firstChild/lastChild/nextSibling
  // for markers moving.
  function keyed(key, parent, renderedValues, data, createFn, noOp, beforeNode) {
      // Fast path for clear
      if (data.length === 0) {
          parent.textContent = "";
          return
      }

      // Fast path for create
      if (renderedValues.length === 0) {
          let node;
          for(let i = 0, len = data.length; i < len; i++) {
              node = createFn(data[i]);
              parent.appendChild(node);
          }
          return
      }

      let prevStart = 0,
          newStart = 0,
          loop = true,
          prevEnd = renderedValues.length-1, newEnd = data.length-1,
          a, b,
          prevStartNode = beforeNode ? beforeNode.nextSibling : parent.firstChild,
          newStartNode = prevStartNode,
          prevEndNode = parent.lastChild,
          newEndNode = prevEndNode,
          afterNode;
      
      fixes: while(loop) {
          loop = false;
          let _node;

          // Skip prefix
          a = renderedValues[prevStart], b = data[newStart];
          while(a[key] === b[key]) {
              noOp(prevStartNode, b);
              prevStart++;
              newStart++;
              newStartNode = prevStartNode = prevStartNode.nextSibling;
              if (prevEnd < prevStart || newEnd < newStart) break fixes
              a = renderedValues[prevStart];
              b = data[newStart];
          }

          // Skip suffix
          a = renderedValues[prevEnd], b = data[newEnd];
          while(a[key] === b[key]) {
              noOp(prevEndNode, b);
              prevEnd--;
              newEnd--;
              afterNode = prevEndNode;
              newEndNode = prevEndNode = prevEndNode.previousSibling;
              if (prevEnd < prevStart || newEnd < newStart) break fixes
              a = renderedValues[prevEnd];
              b = data[newEnd];
          }

          // Fast path to swap backward
          a = renderedValues[prevEnd], b = data[newStart];
          while(a[key] === b[key]) {
              loop = true;
              noOp(prevEndNode, b);
              _node = prevEndNode.previousSibling;
              parent.insertBefore(prevEndNode, newStartNode);
              newEndNode = prevEndNode = _node;
              newStart++;
              prevEnd--;
              if (prevEnd < prevStart || newEnd < newStart) break fixes
              a = renderedValues[prevEnd];
              b = data[newStart];
          }

          // Fast path to swap forward
          a = renderedValues[prevStart], b = data[newEnd];
          while(a[key] === b[key]) {
              loop = true;
              noOp(prevStartNode, b);
              _node = prevStartNode.nextSibling;
              parent.insertBefore(prevStartNode, afterNode);
              prevStart++;
              afterNode = newEndNode = prevStartNode;
              prevStartNode = _node;
              newEnd--;
              if (prevEnd < prevStart || newEnd < newStart) break fixes
              a = renderedValues[prevStart];
              b = data[newEnd];
          }
      }

      // Fast path for shrink
      if (newEnd < newStart) {
          if (prevStart <= prevEnd) {
              let next;
              while(prevStart <= prevEnd) {
                  if (prevEnd === 0) {
                      parent.removeChild(prevEndNode);
                  } else {
                      next = prevEndNode.previousSibling;    
                      parent.removeChild(prevEndNode);
                      prevEndNode = next;
                  }
                  prevEnd--;
              }
          }
          return
      }

      // Fast path for add
      if (prevEnd < prevStart) {
          if (newStart <= newEnd) {
              let node, mode = afterNode ? 1 : 0;
              while(newStart <= newEnd) {
                  node = createFn(data[newStart]);
                  mode ? parent.insertBefore(node, afterNode) : parent.appendChild(node);
                  newStart++;
              }
          }
          return
      }

      // Positions for reusing nodes from current DOM state
      const P = new Array(newEnd + 1 - newStart);
      for(let i = newStart; i <= newEnd; i++) P[i] = -1;

      // Index to resolve position from current to new
      const I = new Map();
      for(let i = newStart; i <= newEnd; i++) I.set(data[i][key], i);

      let reusingNodes = 0, toRemove = [];
      for(let i = prevStart; i <= prevEnd; i++) {
          if (I.has(renderedValues[i][key])) {
              P[I.get(renderedValues[i][key])] = i;
              reusingNodes++;
          } else {
              toRemove.push(i);
          }
      }

      // Fast path for full replace
      if (reusingNodes === 0) {
          if (beforeNode) {
              let node = beforeNode.nextSibling, tmp;
              while(prevStart <= prevEnd) {
                  tmp = node.nextSibling;
                  parent.removeChild(node);
                  node = tmp;
                  prevStart++;
              }
          } else {
              parent.textContent = "";
          }
          let node;
          for(let i = newStart; i <= newEnd; i++) {
              node = createFn(data[i]);
              parent.appendChild(node);
          }

          return
      }

      // What else?
      const longestSeq = longestPositiveIncreasingSubsequence(P, newStart);

      // Collect nodes to work with them
      const nodes = [];
      let tmpC = prevStartNode;
      for(let i = prevStart; i <= prevEnd; i++) {
          nodes[i] = tmpC;
          tmpC = tmpC.nextSibling;
      }

      for(let i = 0; i < toRemove.length; i++) parent.removeChild(nodes[toRemove[i]]);

      let lisIdx = longestSeq.length - 1, tmpD;
      for(let i = newEnd; i >= newStart; i--) {
          if(longestSeq[lisIdx] === i) {
              afterNode = nodes[P[longestSeq[lisIdx]]];
              noOp(afterNode, data[i]);
              lisIdx--;
          } else {
              if (P[i] === -1) {
                  tmpD = createFn(data[i]);
              } else {
                  tmpD = nodes[P[i]];
                  noOp(tmpD, data[i]);
              }
              parent.insertBefore(tmpD, afterNode);
              afterNode = tmpD;
          }
      }
  }

  // Picked from
  // https://github.com/adamhaile/surplus/blob/master/src/runtime/content.ts#L368

  // return an array of the indices of ns that comprise the longest increasing subsequence within ns
  function longestPositiveIncreasingSubsequence(ns, newStart) {
      var seq = [],
          is  = [],
          l   = -1,
          pre = new Array(ns.length);

      for (var i = newStart, len = ns.length; i < len; i++) {
          var n = ns[i];
          if (n < 0) continue;
          var j = findGreatestIndexLEQ(seq, n);
          if (j !== -1) pre[i] = is[j];
          if (j === l) {
              l++;
              seq[l] = n;
              is[l]  = i;
          } else if (n < seq[j + 1]) {
              seq[j + 1] = n;
              is[j + 1] = i;
          }
      }

      for (i = is[l]; l >= 0; i = pre[i], l--) {
          seq[l] = i;
      }

      return seq;
  }

  function findGreatestIndexLEQ(seq, n) {
      // invariant: lo is guaranteed to be index of a value <= n, hi to be >
      // therefore, they actually start out of range: (-1, last + 1)
      var lo = -1,
          hi = seq.length;
      
      // fast path for simple increasing sequences
      if (hi > 0 && seq[hi - 1] <= n) return hi - 1;

      while (hi - lo > 1) {
          var mid = Math.floor((lo + hi) / 2);
          if (seq[mid] > n) {
              hi = mid;
          } else {
              lo = mid;
          }
      }

      return lo;
  }

  const cellView = h`<td class="TableCell">#text</td>`;
  function TableCell(data) {
      const root = cellView.cloneNode(true);
      const refs = cellView.collect(root);

      const { text } = refs;

      text.nodeValue = data;

      root.__click = () => console.log("Click", data);

      let a = data;
      root.update = function (data) {
          if (data !== a) a = text.nodeValue = data;
      };

      return root;
  }

  const rowView = h`<tr></tr>`;
  function TableRow(item) {
      const root = rowView.cloneNode(true);

      root.className = item.active ? 'TableRow active' : 'TableRow';
      root.dataset.id = item.id;

      const id = TableCell('#' + item.id);
      root.appendChild(id);

      let renderedProps = [];
      root.update = function (item) {
          keyed('id', root, renderedProps, item.props, item => TableCell(item), (node, item) => node.update(item), id);
          renderedProps = item.props.slice();
      };
      root.update(item);

      return root;
  }

  const tableView = h`<table class="Table"><tbody #tbody></tbody></table>`;
  function Table(data) {
      const root = tableView.cloneNode(true);
      const refs = tableView.collect(root);

      const { tbody } = refs;

      let renderedItems = [];
      root.update = function (data) {
          keyed('id', tbody, renderedItems, data.table.items, item => TableRow(item), (node, item) => node.update(item));
          renderedItems = data.table.items.slice();
      };
      root.update(data);

      return root;
  }

  const boxView = h`<div class="AnimBox"></div>`;
  function AnimBox(item) {
      const root = boxView.cloneNode(true);

      root.dataset.id = item.id;

      const style = root.style;

      let b, b2;
      root.update = function (item) {
          b2 = item.time;

          if (b2 !== b) {
              style.background = "rgba(0,0,0," + (0.5 + b2 % 10 / 10) + ")";
              style.borderRadius = b2 % 10 + "px";
              b = b2;
          }
      };
      root.update(item);

      return root;
  }

  const animView = h`<div class="Anim"></div>`;
  function Anim(data) {
      const root = animView.cloneNode(true);

      let renderedItems = [];
      root.update = function (data) {
          keyed('id', root, renderedItems, data.anim.items, item => AnimBox(item), (node, item) => node.update(item));
          renderedItems = data.anim.items.slice();
      };
      root.update(data);

      return root;
  }

  const leafView = h`<li class="TreeLeaf">#id</li>`;
  function TreeLeaf(node) {
      const root = leafView.cloneNode(true);
      const refs = leafView.collect(root);

      const { id } = refs;

      id.nodeValue = node.id;

      return root;
  }

  const nodeView = h`<ul class="TreeNode"></ul>`;
  function TreeNode(node) {
      const root = nodeView.cloneNode(true);

      let renderedItems = [];
      root.update = function (node) {
          keyed('id', root, renderedItems, node.children, node => node.container ? TreeNode(node) : TreeLeaf(node), () => {});
          renderedItems = node.children.slice();
      };
      root.update(node);

      return root;
  }

  const treeView = h`<div class="Tree"></div>`;
  function Tree(data) {
      const root = treeView.cloneNode(true);

      const node = TreeNode(data.tree.root);
      root.appendChild(node);

      root.update = function (data) {
          node.update(data.tree.root);
      };

      return root;
  }

  const mainView = h`<div class="Main">#section</div>`;
  function Main() {
      const root = mainView;
      const refs = mainView.collect(root);

      let { section } = refs;

      function route(location, data) {
          if (location === 'table') {
              return Table(data);
          } else if (location === 'anim') {
              return Anim(data);
          } else if (location === 'tree') {
              return Tree(data);
          }
      }

      let a = '',
          a2,
          newSection;
      root.update = function (data) {
          a2 = data.location;

          if (a2 !== a) {
              newSection = route(a2, data);
              root.replaceChild(newSection, section);
              section = newSection;
              a = a2;
          } else {
              section.update(data);
          }
      };

      return root;
  }

  uibench.init("stage0", "0.0.2");

  document.addEventListener("DOMContentLoaded", e => {
      setupSyntheticEvent('click');

      const container = document.querySelector("#App");
      const app = Main();
      container.appendChild(app);

      uibench.run(state => app.update(state), samples => console.debug({ samples }));
  });

}());
//# sourceMappingURL=app.min.js.map
